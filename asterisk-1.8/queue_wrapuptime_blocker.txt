diff --git a/apps/app_queue.c b/apps/app_queue.c
index 1349d04..b51e7b9 100644
--- a/apps/app_queue.c
+++ b/apps/app_queue.c
@@ -1185,10 +1185,97 @@ static AST_LIST_HEAD_STATIC(rule_lists, rule_list);
 
 static struct ao2_container *queues;
 
+static struct ast_sched_thread *sched_thread;
+
 static void update_realtime_members(struct call_queue *q);
 static int set_member_paused(const char *queuename, const char *interface, const char *reason, int paused);
 
 static void queue_transfer_fixup(void *data, struct ast_channel *old_chan, struct ast_channel *new_chan); 
+
+static enum ast_device_state queue_wrapup_blocker_cb(const char *data)
+{
+	/*
+	 * If the value isn't cached, then it's definitely NOT_INUSE.
+	 */
+	return AST_DEVICE_NOT_INUSE;
+}
+
+static void make_devstate_str(char *buf, size_t len, const char *interface)
+{
+	char *c;
+
+	snprintf(buf, len, "QueueWrapupBlocker:%s", interface);
+
+	if ((c = strchr(buf, '/'))) {
+		/*
+		 * Having a '/' in the custom device state name will break the internals
+		 * of device state processing.
+		 */
+		*c = '_';
+	}
+}
+
+static void member_answered_hook(struct member *mem)
+{
+	char buf[1024];
+
+	make_devstate_str(buf, sizeof(buf), S_OR(mem->state_interface, mem->interface));
+
+	ast_devstate_changed(AST_DEVICE_INUSE, "%s", buf);
+}
+
+static int unblock_member(const void *data)
+{
+	char *mem_state_interface = (char *) data;
+	char buf[1024];
+
+	make_devstate_str(buf, sizeof(buf), mem_state_interface);
+	ast_devstate_changed(AST_DEVICE_NOT_INUSE, "%s", buf);
+
+	ast_free(mem_state_interface);
+
+	return 0;
+}
+
+static void member_hangup_hook(struct member *mem, struct call_queue *q)
+{
+	char *mem_state_interface;
+	int res;
+
+	if (!(mem_state_interface = ast_strdup(S_OR(mem->state_interface, mem->interface)))) {
+		ast_log(LOG_ERROR, "Memory allocation failed.  Queue wrapup blocker state will be incorrect.\n");
+		return;
+	}
+
+	if (!q->wrapuptime) {
+		unblock_member(mem_state_interface);
+		return;
+	}
+
+	res = ast_sched_thread_add(sched_thread, q->wrapuptime * 1000, unblock_member, mem_state_interface);
+	if (res == -1) {
+		ast_log(LOG_ERROR, "Failed to schedule wrapuptime ublock, unblocking now.\n");
+		unblock_member(mem_state_interface);
+	}
+}
+
+/*!
+ * \internal
+ * \retval non-zero blocker active
+ * \retval 0 blocker not active
+ */
+static int check_queue_wrapup_blocker(struct member *mem)
+{
+	char buf[1024];
+	char workspace[1024] = "";
+
+	make_devstate_str(buf, sizeof(buf), S_OR(mem->state_interface, mem->interface));
+
+	ast_func_read(NULL, buf, workspace, sizeof(workspace));
+
+	return !strcasecmp(workspace, "INUSE");
+}
+
 /*! \brief sets the QUEUESTATUS channel variable */
 static void set_queue_result(struct ast_channel *chan, enum queue_result res)
 {
@@ -1394,6 +1481,9 @@ static int get_member_status(struct call_queue *q, int max_penalty, int min_pena
 			} else if ((conditions & QUEUE_EMPTY_WRAPUP) && member->lastcall && q->wrapuptime && (time(NULL) - q->wrapuptime < member->lastcall)) {
 				ast_debug(4, "%s is unavailable because it has only been %d seconds since his last call (wrapup time is %d)\n", member->membername, (int) (time(NULL) - member->lastcall), q->wrapuptime);
 				break;
+			} else if (check_queue_wrapup_blocker(member)) {
+				ast_debug(4, "%s is unavailable because the wrapup blocker is active.\n", member->membername);
+				break;
 			} else {
 				ao2_unlock(q);
 				ao2_ref(member, -1);
@@ -2869,7 +2959,7 @@ static int num_available_members(struct call_queue *q)
 			/* else fall through */
 		case AST_DEVICE_NOT_INUSE:
 		case AST_DEVICE_UNKNOWN:
-			if (!mem->paused) {
+			if (!mem->paused && !check_queue_wrapup_blocker(mem)) {
 				avl++;
 			}
 			break;
@@ -3019,6 +3109,14 @@ static int ring_entry(struct queue_ent *qe, struct callattempt *tmp, int *busies
 		return 0;
 	}
 
+	if (check_queue_wrapup_blocker(tmp->member)) {
+		ast_debug(1, "%s still wrapping up (determined using distributed wrapup blocker)\n", tmp->interface);
+		if (qe->chan->cdr)
+			ast_cdr_busy(qe->chan->cdr);
+		tmp->stillgoing = 0;
+		return 0;
+	}
+
 	if (tmp->member->paused) {
 		ast_debug(1, "%s paused, can't receive call\n", tmp->interface);
 		if (qe->chan->cdr)
@@ -3647,6 +3745,7 @@ static struct callattempt *wait_for_answer(struct queue_ent *qe, struct callatte
 						case AST_CONTROL_ANSWER:
 							/* This is our guy if someone answered. */
 							if (!peer) {
+								member_answered_hook(o->member);
 								ast_verb(3, "%s answered %s\n", ochan_name, inchan_name);
 								if (update_connectedline) {
 									if (o->pending_connected_update) {
@@ -5035,6 +5134,8 @@ static int try_calling(struct queue_ent *qe, const char *options, char *announce
 		transfer_ds = setup_transfer_datastore(qe, member, callstart, callcompletedinsl);
 		bridge = ast_bridge_call(qe->chan,peer, &bridge_config);
 
+		member_hangup_hook(member, qe->parent);
+
 		/* If the queue member did an attended transfer, then the TRANSFER already was logged in the queue_log
 		 * when the masquerade occurred. These other "ending" queue_log messages are unnecessary, except for
 		 * the AgentComplete manager event
@@ -6185,7 +6286,7 @@ static int queue_function_qac(struct ast_channel *chan, const char *cmd, char *d
 			mem_iter = ao2_iterator_init(q->members, 0);
 			while ((m = ao2_iterator_next(&mem_iter))) {
 				/* Count the agents who are logged in and presently answering calls */
-				if ((m->status == AST_DEVICE_NOT_INUSE) && (!m->paused)) {
+				if ((m->status == AST_DEVICE_NOT_INUSE) && (!m->paused) && !check_queue_wrapup_blocker(m)) {
 					count++;
 				}
 				ao2_ref(m, -1);
@@ -6197,7 +6298,7 @@ static int queue_function_qac(struct ast_channel *chan, const char *cmd, char *d
 			mem_iter = ao2_iterator_init(q->members, 0);
 			while ((m = ao2_iterator_next(&mem_iter))) {
 				/* Count the agents who are logged in, not paused and not wrapping up */
-				if ((m->status == AST_DEVICE_NOT_INUSE) && (!m->paused) &&
+				if ((m->status == AST_DEVICE_NOT_INUSE) && (!m->paused) && !check_queue_wrapup_blocker(m) &&
 						!(m->lastcall && q->wrapuptime && ((now - q->wrapuptime) < m->lastcall))) {
 					count++;
 				}
@@ -6244,7 +6345,7 @@ static int queue_function_qac_dep(struct ast_channel *chan, const char *cmd, cha
 		mem_iter = ao2_iterator_init(q->members, 0);
 		while ((m = ao2_iterator_next(&mem_iter))) {
 			/* Count the agents who are logged in and presently answering calls */
-			if ((m->status != AST_DEVICE_UNAVAILABLE) && (m->status != AST_DEVICE_INVALID)) {
+			if ((m->status != AST_DEVICE_UNAVAILABLE) && (m->status != AST_DEVICE_INVALID) && !check_queue_wrapup_blocker(m)) {
 				count++;
 			}
 			ao2_ref(m, -1);
@@ -7139,7 +7240,7 @@ static int manager_queues_summary(struct mansession *s, const struct message *m)
 			while ((mem = ao2_iterator_next(&mem_iter))) {
 				if ((mem->status != AST_DEVICE_UNAVAILABLE) && (mem->status != AST_DEVICE_INVALID)) {
 					++qmemcount;
-					if (((mem->status == AST_DEVICE_NOT_INUSE) || (mem->status == AST_DEVICE_UNKNOWN)) && !(mem->paused)) {
+					if (((mem->status == AST_DEVICE_NOT_INUSE) || (mem->status == AST_DEVICE_UNKNOWN)) && !(mem->paused) && !check_queue_wrapup_blocker(mem)) {
 						++qmemavail;
 					}
 				}
@@ -8303,6 +8404,8 @@ static int unload_module(void)
 	ao2_ref(queues, -1);
 	devicestate_tps = ast_taskprocessor_unreference(devicestate_tps);
 	ast_unload_realtime("queue_members");
+	sched_thread = ast_sched_thread_destroy(sched_thread);
+	ast_devstate_prov_del("QueueWrapupBlocker");
 	return res;
 }
 
@@ -8312,6 +8415,14 @@ static int load_module(void)
 	struct ast_context *con;
 	struct ast_flags mask = {AST_FLAGS_ALL, };
 
+	if (!(sched_thread = ast_sched_thread_create())) {
+		return AST_MODULE_LOAD_DECLINE;
+	}
+
+	if (ast_devstate_prov_add("QueueWrapupBlocker", queue_wrapup_blocker_cb)) {
+		return AST_MODULE_LOAD_DECLINE;
+	}
+
 	queues = ao2_container_alloc(MAX_QUEUE_BUCKETS, queue_hash_cb, queue_cmp_cb);
 
 	use_weight = 0;
